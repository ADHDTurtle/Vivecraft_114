--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -13,16 +13,43 @@
 import com.mojang.authlib.properties.PropertyMap;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
 import com.mojang.datafixers.DataFixer;
+import com.mtbs3d.minecrift.api.ErrorHelper;
+import com.mtbs3d.minecrift.gameplay.OpenVRPlayer;
+import com.mtbs3d.minecrift.gameplay.trackers.BackpackTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.BowTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.ClimbTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.EatingTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.HorseTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.JumpTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.RowTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.RunTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.SneakTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.SwimTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.SwingTracker;
+import com.mtbs3d.minecrift.gameplay.trackers.TeleportTracker;
+import com.mtbs3d.minecrift.provider.OpenVRStereoRenderer;
+import com.mtbs3d.minecrift.render.MenuWorldRenderer;
+import com.mtbs3d.minecrift.settings.VRSettings;
+
+import de.fruitfly.ovr.structs.GLConfig;
+
+import java.awt.Cursor;
 import java.io.File;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Queue;
@@ -39,10 +66,67 @@
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+import javax.imageio.ImageIO;
+
+import com.mtbs3d.minecrift.gameplay.trackers.*;
+import org.apache.commons.io.Charsets;
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.opengl.ARBShaderObjects;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL13;
+import org.lwjgl.opengl.GL30;
+
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import com.google.common.hash.Hashing;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import com.mojang.authlib.AuthenticationService;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.authlib.properties.PropertyMap;
+import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import com.mtbs3d.minecrift.api.ErrorHelper;
+import com.mtbs3d.minecrift.control.VRButtonMapping;
+import com.mtbs3d.minecrift.provider.MCOpenVR;
+import com.mtbs3d.minecrift.gameplay.OpenVRPlayer;
+import com.mtbs3d.minecrift.gameplay.screenhandlers.GuiHandler;
+import com.mtbs3d.minecrift.gameplay.screenhandlers.KeyboardHandler;
+import com.mtbs3d.minecrift.gameplay.screenhandlers.RadialHandler;
+import com.mtbs3d.minecrift.provider.OpenVRStereoRenderer;
+import com.mtbs3d.minecrift.render.MenuWorldRenderer;
+import com.mtbs3d.minecrift.render.PlayerModelController;
+import com.mtbs3d.minecrift.render.RenderConfigException;
+import com.mtbs3d.minecrift.render.ShaderHelper;
+import com.mtbs3d.minecrift.render.VRShaders;
+import com.mtbs3d.minecrift.render.renderPass;
+import com.mtbs3d.minecrift.settings.VRHotkeys;
+import com.mtbs3d.minecrift.settings.VRSettings;
+import com.mtbs3d.minecrift.settings.VRSettings.VrOptions;
+import com.mtbs3d.minecrift.utils.MCReflection;
+import com.mtbs3d.minecrift.utils.MenuWorldDownloader;
+import com.mtbs3d.minecrift.utils.MenuWorldExporter;
+import com.mtbs3d.minecrift.utils.Utils;
+import com.mtbs3d.minecrift.utils.LWJGL.Matrix4f;
+
+import de.fruitfly.ovr.structs.FovPort;
+import de.fruitfly.ovr.structs.GLConfig;
+import de.fruitfly.ovr.structs.RenderTextureInfo;
+import de.fruitfly.ovr.structs.RenderTextureSet;
+import de.fruitfly.ovr.structs.Sizei;
 import net.minecraft.block.Block;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.audio.MusicTicker;
 import net.minecraft.client.audio.SoundHandler;
+import net.minecraft.client.audio.SoundManager;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.gui.GuiChat;
@@ -79,6 +163,7 @@
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.EntityRenderer;
 import net.minecraft.client.renderer.FirstPersonRenderer;
+import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GlDebugTextUtils;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.ItemRenderer;
@@ -107,6 +192,7 @@
 import net.minecraft.client.settings.CreativeSettings;
 import net.minecraft.client.settings.KeyBinding;
 import net.minecraft.client.shader.Framebuffer;
+import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.tutorial.Tutorial;
 import net.minecraft.client.util.ISearchTree;
 import net.minecraft.client.util.ITooltipFlag;
@@ -158,6 +244,7 @@
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.integrated.IntegratedServer;
 import net.minecraft.server.management.PlayerProfileCache;
+import net.minecraft.src.Config;
 import net.minecraft.stats.StatisticsManager;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.tileentity.TileEntitySkull;
@@ -177,6 +264,7 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.Vec3d;
 import net.minecraft.util.registry.IRegistry;
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.util.text.TextComponentKeybind;
@@ -193,6 +281,8 @@
 import net.minecraft.world.storage.ISaveFormat;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.WorldInfo;
+import net.optifine.shaders.Shaders;
+
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -203,6 +293,107 @@
 
 public class Minecraft implements IThreadListener, ISnooperInfo, IGuiEventListenerDeferred
 {
+	// VIVE START - teleport movement
+	public OpenVRPlayer vrPlayer; 
+	public BackpackTracker backpackTracker = new BackpackTracker(this);
+	public BowTracker bowTracker = new BowTracker(this);
+	public SwimTracker swimTracker = new SwimTracker(this);
+	public EatingTracker autoFood=new EatingTracker(this);
+	public JumpTracker jumpTracker=new JumpTracker(this);
+	public SneakTracker sneakTracker=new SneakTracker(this);
+	public ClimbTracker climbTracker = new ClimbTracker(this);
+	public RunTracker runTracker  = new RunTracker(this);
+	public RowTracker rowTracker  = new RowTracker(this);
+	public TeleportTracker teleportTracker = new TeleportTracker(this);
+	public SwingTracker swingTracker = new SwingTracker(this);
+	public HorseTracker horseTracker = new HorseTracker(this);
+	// VIVE END - teleport movement
+	
+	/** MINECRIFT */
+	public FloatBuffer[] eyeproj = new FloatBuffer[2]; //i dislike you.
+	public FloatBuffer[] cloudeyeproj = new FloatBuffer[2]; //i dislike you too.
+	
+	public boolean minecriftDebug = false;
+	public final float PIOVER180 = (float)(Math.PI/180);
+	public boolean reinitFramebuffers = true;
+	
+	//public Framebuffer framebuffer;
+	public Framebuffer framebufferMR;
+	private Framebuffer framebufferUndistorted;
+	private Framebuffer framebufferEye0;
+	private Framebuffer framebufferEye1;
+
+	public int lastDisplayFBWidth = 0;
+	public int lastDisplayFBHeight = 0;
+	public int displayFBWidth;     /* Actual width of the display buffer */
+	public int displayFBHeight;    /* Actual height of the display buffer */
+	public int mirrorFBWidth;     /* Actual width of the display buffer */
+	public int mirrorFBHeight;    /* Actual height of the display buffer */
+	public ShaderGroup shaderGroup;
+	public int lastShaderIndex = -1;
+	public Object displayImpl = null;
+	public Field fieldHwnd = null;
+	public Field fieldDisplay = null;
+	public Field fieldWindow = null;
+	public Field fieldResized = null;
+	public Method fieldResizedMethod = null;
+	public OpenVRStereoRenderer stereoProvider;
+	public VRSettings vrSettings;
+	public long lastIntegratedServerLaunchCheck = 0;
+	public boolean integratedServerLaunchInProgress = false;
+	public boolean lastEnableVsync = true;
+	public int grabScreenShot = 0;
+	public Cursor nativeMouseCursor = null;
+	public boolean lastShowMouseNative = true;
+	public Cursor invisibleMouseCursor = null;
+	public GLConfig glConfig = new GLConfig();
+	public long lastWindow = 0;
+	public int lastRenderDistanceChunks = -1;
+	public boolean lastFogFancy = true;
+	public boolean lastFogFast = false;
+	public float lastWorldScale = 0f;
+	public boolean enableWorldExport = false;
+	public DimensionType lastDimensionId = DimensionType.OVERWORLD;
+	public SoundManager sndManager = null;
+	public MenuWorldRenderer menuWorldRenderer;
+
+	
+	private FloatBuffer matrixBuffer = GLAllocation.createDirectFloatBuffer(16);
+	private FloatBuffer matrixBuffer2 = GLAllocation.createDirectFloatBuffer(16);
+	private Framebuffer mirrorFB = null;
+	private Framebuffer fsaaFirstPassResultFBO;
+	private Framebuffer fsaaLastPassResultFBO;
+
+	private boolean firstInit = true;
+	public boolean showSplashScreen = true;
+	public long splashTimer1 = 0;
+	public long splashTimer2 = 0;
+	private Framebuffer splash;
+	private float splashFadeAlpha = 0;
+	private int lastGuiScale = -1;
+	public Deque<Long> runTickTimeNanos = new ArrayDeque<Long>();
+	public long medianRunTickTimeNanos = 0;
+	public long frameIndex = 0;
+	public ErrorHelper errorHelper;
+	public static final String RENDER_SETUP_FAILURE_MESSAGE = "Failed to initialise stereo rendering plugin: ";
+	public renderPass currentPass;
+	private boolean lastClick;
+
+	public int hmdAvgLength = 90;
+	public LinkedList<Vec3d> hmdPosSamples = new LinkedList<Vec3d>();
+	public LinkedList<Float> hmdYawSamples = new LinkedList<Float>();
+	private float hmdYawTotal;
+	private float hmdYawLast;
+	public int tickCounter;
+	private boolean trigger;
+	/*
+	 * The minecriftVerString will be automatically updated by the build scripts, do not modify here.
+	 * Modify minecriftversion.py in root minecrift dir.
+	 */
+    public final String minecriftVerString = "Vivecraft 1.13.2 jrbudda-1-a0";
+	/* end version */
+	/** END MINECRIFT */
+    
     private static final Logger LOGGER = LogManager.getLogger();
     public static final boolean IS_RUNNING_ON_MAC = Util.getOSType() == Util.EnumOS.OSX;
     public static final ResourceLocation DEFAULT_FONT_RENDERER_NAME = new ResourceLocation("default");
@@ -2726,4 +2917,1214 @@
     {
         return this.fontResourceMananger;
     }
+    //VIVECRAFT ADDITIONS **************************************************************************
+    
+   
+	public void printChatMessage(String msg)
+	{
+		if (this.world != null) {
+			ITextComponent chatText = new TextComponentString(msg);
+			this.ingameGUI.getChatGUI().printChatMessage(chatText);
+		}
+	}
+    
+	public Matrix4f getMRTransform(){
+		//I swear to god this should be correct for column-major and post-multiplication for view matrix
+
+		Vec3d roomo = vrPlayer.vrdata_world_render.origin;
+
+		FloatBuffer conrot = null;	
+
+		Object temp;
+		if(MCOpenVR.mrMovingCamActive){
+			de.fruitfly.ovr.structs.Matrix4f temp2 = MCOpenVR.getAimRotation(2);
+			conrot = temp2.inverted().toFloatBuffer();
+		}else {
+			//reconstruct from vrsettings		
+			Matrix4f m = new Matrix4f();
+
+			m=m.rotate((float) Math.toRadians(-vrSettings.vrFixedCamrotYaw), new com.mtbs3d.minecrift.utils.LWJGL.Vector3f(0, 1, 0));
+			m=m.rotate((float) Math.toRadians(-vrSettings.vrFixedCamrotPitch), new com.mtbs3d.minecrift.utils.LWJGL.Vector3f(1, 0, 0));
+			m=m.rotate((float) Math.toRadians(vrSettings.vrFixedCamrotRoll), new com.mtbs3d.minecrift.utils.LWJGL.Vector3f(0, 0, 1));
+			m=m.rotate((float) Math.toRadians(180), new com.mtbs3d.minecrift.utils.LWJGL.Vector3f(0, 1, 0));
+			
+			matrixBuffer2.rewind();
+			m.store(matrixBuffer2);
+			matrixBuffer2.rewind();
+			conrot = matrixBuffer2;
+			
+		}
+
+		GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+		GlStateManager.pushMatrix();
+			GlStateManager.loadIdentity();
+	
+			//Room pose
+			GlStateManager.translated(-roomo.x, -roomo.y, -roomo.z);
+			GlStateManager.rotatef((float) Math.toDegrees(vrPlayer.vrdata_world_render.rotation), 0, 1, 0);
+			//
+			//scale everything in the room
+			GlStateManager.scalef(vrPlayer.vrdata_world_render.worldScale,
+					vrPlayer.vrdata_world_render.worldScale, 
+					vrPlayer.vrdata_world_render.worldScale);
+			///
+			
+			//Device Pose
+			Vec3d cp = vrPlayer.vrdata_room_pre.getController(2).getPosition();
+
+			GlStateManager.translated(-cp.x, -cp.y, -cp.z);
+							
+			//local rots
+			GlStateManager.rotatef(vrSettings.mrMovingCamOffsetYaw, 0.0F, 1.0F, 0.0F);
+			GlStateManager.rotatef(vrSettings.mrMovingCamOffsetRoll, 0.0F, 0.0F, 1.0F);
+			GlStateManager.rotatef(vrSettings.mrMovingCamOffsetPitch, 1.0F, 0.0F, 0.0F);
+			
+			//this is here because.
+			GlStateManager.multMatrixf(conrot);
+	
+			//local offsets
+			GlStateManager.translatef(-vrSettings.mrMovingCamOffsetX, -vrSettings.mrMovingCamOffsetY, -vrSettings.mrMovingCamOffsetZ);
+	
+	
+			//put back scale
+			GlStateManager.scalef(1/vrPlayer.vrdata_world_render.worldScale, 1/vrPlayer.vrdata_world_render.worldScale, 1/vrPlayer.vrdata_world_render.worldScale);
+			//
+	
+			GlStateManager.getFloatv(GL11.GL_MODELVIEW_MATRIX, matrixBuffer);
+		GlStateManager.popMatrix();
+
+		matrixBuffer.rewind();
+		this.thirdPassViewMatrix.load(matrixBuffer);
+		matrixBuffer.rewind();
+		return thirdPassViewMatrix;
+	}
+	
+	
+	public void printGLMatrix(String derp){
+		GlStateManager.getFloatv(GL11.GL_MODELVIEW_MATRIX, matrixBuffer);
+		matrixBuffer.rewind();
+		Matrix4f temp = new Matrix4f();
+		temp.load(matrixBuffer);
+		System.out.println(derp + "\r\n" + temp.toString());
+		matrixBuffer.rewind();
+	}
+	
+	public void clearGLError() //bad bad bad
+	{
+		int var2 = GL11.glGetError();
+	}
+	//public org.lwjgl.util.vector.Matrix4f thirdPassInverseViewMatrix = new org.lwjgl.util.vector.Matrix4f();
+	public com.mtbs3d.minecrift.utils.LWJGL.Matrix4f thirdPassViewMatrix = new Matrix4f();
+
+	private boolean copyToMirror(renderPass currentPass2)
+	{
+		// VIVE start - render eye buffers to the desktop window
+
+		if(this.vrSettings.displayMirrorMode < vrSettings.MIRROR_OFF) //new values
+			this.vrSettings.displayMirrorMode = vrSettings.MIRROR_ON_DUAL;
+		
+		if(this.vrSettings.displayMirrorMode > vrSettings.MIRROR_MIXED_REALITY) //new values
+			this.vrSettings.displayMirrorMode = vrSettings.MIRROR_ON_DUAL;
+		
+		if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_OFF && MCOpenVR.isHMDTracking())
+		{
+			return false;
+		} 
+		else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_MIXED_REALITY /*&& renderViewEntity != null*/) 
+		{			
+			if(currentPass2 != renderPass.Third) return false;
+
+			if (VRShaders._DepthMask_shaderProgramId != 0) {
+				doMixedRealityMirror();
+			} else {
+				this.framebufferMc.unbindFramebuffer();	//draw directly to window
+				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);
+				entityRenderer.displayNotificationText("Shader compile failed, see log", "", "", this.displayWidth, this.displayHeight, false, true);
+			}
+
+			return true;
+		} else { //left, right, undistorted, third.
+			int ports = 1;
+			Framebuffer source = this.framebufferEye0;
+			int i = 0;
+
+			if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_FIRST_PERSON ) {
+				source = framebufferUndistorted;
+			}else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_THIRD_PERSON){
+				getMRTransform();
+				source = framebufferMR;
+			} else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_DUAL){
+				ports = 2;
+				if(currentPass2 == renderPass.Right) {
+					source = framebufferEye1;
+					i=1;
+				}
+			} else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_SINGLE){
+				if(currentPass2 == renderPass.Left)
+					return false;
+			}
+
+			this.framebufferMc.unbindFramebuffer();	//draw directly to window
+			source.framebufferRenderExt((displayWidth / 2) * i, displayWidth / ports, displayHeight, 0, true);
+			return true;
+			
+		}
+
+	}
+
+	private void doMixedRealityMirror() {
+		boolean hasShaders = Config.isShaders();
+		boolean alphaMask = this.vrSettings.mixedRealityUnityLike && this.vrSettings.mixedRealityAlphaMask;
+		
+		this.framebufferMc.unbindFramebuffer();	//draw directly to window
+					
+		GL30.glBindFramebuffer(GL30.GL_DRAW_FRAMEBUFFER, 0);
+		GL30.glBindFramebuffer(GL30.GL_READ_FRAMEBUFFER, framebufferMR.framebufferObject);
+
+		if (!alphaMask) GlStateManager.clearColor(vrSettings.mixedRealityKeyColor.getRed() / 255F, vrSettings.mixedRealityKeyColor.getGreen() / 255F, vrSettings.mixedRealityKeyColor.getBlue() / 255F, 1);
+		else GlStateManager.clearColor(0, 0, 0, 1);
+		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+		// create view matrix
+		
+		//temp
+//				vrSettings.mrMovingCamOffsetPitch = 0;
+//				vrSettings.mrMovingCamOffsetYaw = 0;
+//				vrSettings.mrMovingCamOffsetRoll = 0f;
+//				
+//				vrSettings.mrMovingCamOffsetX = 0f;
+//				vrSettings.mrMovingCamOffsetY = 0f;
+//				vrSettings.mrMovingCamOffsetZ = 0f;
+//				
+//				vrSettings.vrFixedCamrotYaw = 0;
+//				vrSettings.vrFixedCamrotRoll = 0;
+//				vrSettings.vrFixedCamrotPitch= 0;
+////				
+//				vrSettings.vrFixedCamposX = 0;
+//				vrSettings.vrFixedCamposY = 0;
+//				vrSettings.vrFixedCamposZ= 0;
+//				vrSettings.saveOptions();
+//				
+//				vrSettings.vrWorldRotation +=1f;
+//				vrPlayer.checkandUpdateRotateScale(true, 0);
+		//
+
+		getMRTransform();
+		
+		Vec3d derp = vrPlayer.vrdata_world_render.getController(2).getPosition();
+
+		Vec3d camplayer = new Vec3d(-thirdPassViewMatrix.m30, -thirdPassViewMatrix.m31, -thirdPassViewMatrix.m32).subtract(vrPlayer.vrdata_world_render.getEye(renderPass.Center).getPosition());
+	//	Vec3d camplayer = derp.subtract(vrPlayer.vrdata_world_render.getEye(renderPass.Center).getPosition());
+
+		camplayer = camplayer.rotateYaw((float) Math.PI);
+		
+		
+//	org.lwjgl.util.vector.Vector3f CameraLookx = new org.lwjgl.util.vector.Vector3f(0,0,-1); 
+//	org.lwjgl.util.vector.Vector3f CameraLooky = Utils.directionFromMatrix(thirdPassViewMatrix, 0, 0, -1);
+//	float yaw = (float) Math.toRadians(-vrSettings.vrFixedCamrotYaw - vrSettings.vrWorldRotation);
+//	float yawx = (float) Math.atan2((-thirdPassViewMatrix.m20),(Math.sqrt(Math.pow(thirdPassViewMatrix.m21, 2) + Math.pow(thirdPassViewMatrix.m22, 2))));
+		
+//	org.lwjgl.util.vector.Vector3f CameraLook = new org.lwjgl.util.vector.Vector3f((float) Math.sin(yaw), 0f, (float)Math.cos(yaw));
+
+		org.lwjgl.util.vector.Matrix4f viewMatrix = new org.lwjgl.util.vector.Matrix4f(thirdPassViewMatrix);
+		viewMatrix.m33 =1;
+		viewMatrix.m30 =0;
+		viewMatrix.m31 =0; 
+		viewMatrix.m32 =0;
+		
+		viewMatrix = (Matrix4f) viewMatrix.invert();
+		
+		org.lwjgl.util.vector.Vector3f CameraLook = Utils.directionFromMatrix(viewMatrix, 0, 0, 1);
+		
+		// Vec3d camplayerx = entityRenderer.getMRCamLocation().subtract(entityRenderer.getEyeRenderPos(renderPass.Center));				
+
+		OpenGlHelper.glUseProgram(VRShaders._DepthMask_shaderProgramId);
+		
+		// set projection matrix
+		entityRenderer.thirdPassProjectionMatrix.store(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_projectionMatrix, false, matrixBuffer);
+		
+		// set view matrix
+		viewMatrix.store(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4fvARB(VRShaders._DepthMask_viewMatrix, false, matrixBuffer);
+
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_colorTexUniform, 1);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_depthTexUniform, 2);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdViewPosition, (float)camplayer.x, (float)camplayer.y, (float)camplayer.z);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdPlaneNormal, (float)-CameraLook.x, 0, (float) CameraLook.z);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_keyColorUniform, vrSettings.mixedRealityKeyColor.getRed() / 255F, vrSettings.mixedRealityKeyColor.getGreen() / 255F, vrSettings.mixedRealityKeyColor.getBlue() / 255F);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_alphaModeUniform, alphaMask ? 1 : 0);
+
+		// bind color and depth textures
+		GlStateManager.activeTexture(GL13.GL_TEXTURE1);
+		framebufferMR.bindFramebufferTexture();
+		GlStateManager.activeTexture(GL13.GL_TEXTURE2);
+		
+		if (hasShaders) 
+			GlStateManager.bindTexture(Shaders.dfbDepthTextures.get(0)); // shadersmod has it's own depth buffer
+		else 
+			GlStateManager.bindTexture(framebufferMR.depthBuffer);
+		
+		GlStateManager.activeTexture(GL13.GL_TEXTURE0);
+
+		
+		for(int i = 0; i < (alphaMask ? 3 : 2); i++) {
+		
+			int resW = displayWidth / 2;
+			int resH = displayHeight;
+			int posW = (displayWidth / 2) * i;
+			int posH = 0;
+			
+			if (this.vrSettings.mixedRealityUnityLike) {
+				resW = displayWidth / 2;
+				resH = displayHeight / 2;
+				if (this.vrSettings.mixedRealityAlphaMask && i == 2) {
+					posW = displayWidth / 2;
+					posH = displayHeight / 2;
+				} else {
+					posW = 0;
+					posH = (displayHeight / 2) * (1 - i);
+				}
+			}
+			
+			// set other uniforms
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_resolutionUniform, resW, resH);
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_positionUniform, posW, posH);
+			ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_passUniform, i);
+
+			
+			// draw framebuffer
+			framebufferMR.framebufferRenderExt(posW, resW, resH, posH, true);
+		}
+		
+		OpenGlHelper.glUseProgram(0);
+		
+		if (this.vrSettings.mixedRealityUnityLike) {
+			if(this.vrSettings.mixedRealityMRPlusUndistorted)
+				framebufferUndistorted.framebufferRenderExt(displayWidth / 2, displayWidth / 2, displayHeight / 2, 0, true);
+			else
+				framebufferEye0.framebufferRenderExt(displayWidth / 2, displayWidth / 2, displayHeight / 2, 0, true);
+		}
+
+		
+	}
+
+	private float fov = 1.0f;
+	
+	public boolean reinitflag;
+	private void setupRenderConfiguration() throws Exception 
+	{
+		boolean changeNonDestructiveRenderConfig = false;
+
+		if (clipPlanesChanged())
+		{
+			this.reinitFramebuffers = true;
+		}
+
+		//why?
+//		if (!Display.isActive() && this.fullscreen)
+//		{
+//			this.toggleFullscreen();
+//			this.reinitFramebuffers = true;
+//		}
+
+		if (wasDisplayResized())
+		{
+			Display.update();     // This will set new display widths accordingly
+			this.reinitFramebuffers = true;
+		}
+
+		this.gameSettings.guiScale =3;
+		
+		if (this.lastGuiScale != this.gameSettings.guiScale)
+		{
+			this.lastGuiScale = this.gameSettings.guiScale;
+			this.reinitFramebuffers = true;
+		}
+
+		showNativeMouseCursor(!Display.isActive());
+
+
+		// Check for changes in window handle
+		glConfig = getLWJGLConfig(glConfig);
+		if (glConfig.Window != lastWindow)
+		{
+			this.reinitFramebuffers = true;
+			lastWindow = glConfig.Window;
+		}
+
+		if (lastShaderIndex != this.vrSettings.shaderIndex) {
+			this.reinitFramebuffers = true;
+		}
+
+		if (this.lastEnableVsync != this.gameSettings.enableVsync) {
+			this.reinitFramebuffers = true;
+		}
+
+		if (this.reinitFramebuffers)
+		{
+			this.reinitflag = true;
+			this.visible = true;
+			this.checkGLError("Start Init");
+
+			displayFBWidth = (Display.getWidth() < 1) ? 1 : Display.getWidth();
+			displayFBHeight = (Display.getHeight() < 1) ? 1 : Display.getHeight();
+				
+			Sizei EyeTextureSize = new Sizei(); 
+			
+			EyeTextureSize.w = this.displayWidth = displayFBWidth;
+			EyeTextureSize.h = this.displayHeight = displayFBHeight ;
+
+			FovPort leftFov = null;
+			FovPort rightFov = null;
+
+			if (!this.stereoProvider.isInitialized()) {
+				throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), " " + this.stereoProvider.getinitError());
+			}
+
+			RenderTextureInfo renderTextureInfo = this.stereoProvider.getRenderTextureSizes(this.vrSettings.renderScaleFactor);
+
+			EyeTextureSize.w  = renderTextureInfo.LeftFovTextureResolution.w ;
+			EyeTextureSize.h  = renderTextureInfo.LeftFovTextureResolution.h ;
+
+			if (this.framebuffer != null) {
+				this.framebuffer.deleteFramebuffer();
+				this.framebuffer = null;
+			}
+
+			if (this.framebufferMR != null) {
+				this.framebufferMR.deleteFramebuffer();
+				this.framebufferMR = null;
+			}
+
+			if (this.framebufferUndistorted != null) {
+				this.framebufferUndistorted.deleteFramebuffer();
+				this.framebufferUndistorted = null;
+			}
+
+			if (this.framebufferEye0 != null) {
+				this.framebufferEye0.deleteFramebuffer();
+				this.framebufferEye0 = null;
+			}
+			
+			if (this.framebufferEye1 != null) {
+				this.framebufferEye1.deleteFramebuffer();
+				this.framebufferEye1 = null;
+			}
+			
+			this.stereoProvider.deleteRenderTextures(); ///TODO should this do something.. ?
+
+			if (GuiHandler.guiFramebuffer != null) {
+				GuiHandler.guiFramebuffer.deleteFramebuffer();
+				GuiHandler.guiFramebuffer = null;
+			}
+			
+			if (KeyboardHandler.Framebuffer != null) {
+				KeyboardHandler.Framebuffer.deleteFramebuffer();
+				KeyboardHandler.Framebuffer = null;
+			}
+
+			if (this.loadingScreen != null) {
+			//	this.loadingScreen.deleteFramebuffer();
+			}
+
+			if (this.mirrorFB != null) {
+				this.mirrorFB.deleteFramebuffer();
+				this.mirrorFB = null;
+			}
+
+			this.stereoProvider.deleteMirrorTexture(); 
+
+			if (this.fsaaFirstPassResultFBO != null) {
+				this.fsaaFirstPassResultFBO.deleteFramebuffer();
+				this.fsaaFirstPassResultFBO = null;
+			}
+		
+			if (this.fsaaLastPassResultFBO != null) {
+				this.fsaaLastPassResultFBO.deleteFramebuffer();
+				this.fsaaLastPassResultFBO = null;
+			}
+			
+			int multiSampleCount = 0;
+			boolean multiSample = (multiSampleCount > 0 ? true : false);
+					
+			this.checkGLError("Mirror framebuffer setup");
+
+			int tex0 = -1, tex1 = -1;
+
+			if (this.stereoProvider.providesRenderTextures())
+			{ //always true
+				// Source render textures
+				RenderTextureSet renderTextures = this.stereoProvider.createRenderTexture(
+						EyeTextureSize.w,
+						EyeTextureSize.h);
+				if (renderTextures == null) {
+					throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), this.stereoProvider.getLastError());
+				}
+				print("L Render texture resolution: " + EyeTextureSize.w + " x " + EyeTextureSize.h);
+				print("Provider supplied render texture IDs:\n" + renderTextures.toString());
+
+			    tex0 = renderTextures.leftEyeTextureIds.get(0);
+				tex1 = renderTextures.rightEyeTextureIds.get(0);
+
+			}
+			else
+			{
+				// Generate our textures
+				//renderTexProvider.genTextureIds(GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, EyeTextureSize.w, EyeTextureSize.h, 1);
+			}
+			this.checkGLError("Render Texture setup");
+
+			
+			if (tex0 == -1 || tex1 == -1) {
+				throw new Exception("Failed to create eye textures");
+			}
+			
+			this.framebufferEye0 = new Framebuffer("L Eye", EyeTextureSize.w, EyeTextureSize.h, false,  false, false, 0, tex0);
+			print(this.framebufferEye0.toString());
+			this.checkGLError("Left Eye framebuffer setup");
+			
+			this.framebufferEye1 = new Framebuffer("R Eye", EyeTextureSize.w, EyeTextureSize.h, false,  false, false,0, tex1);
+			print(this.framebufferEye1.toString());
+			this.checkGLError("Right Eye framebuffer setup");
+			
+			this.displayFBWidth = (int) Math.ceil(EyeTextureSize.w * this.vrSettings.renderScaleFactor);
+			this.displayFBHeight = (int) Math.ceil(EyeTextureSize.h * this.vrSettings.renderScaleFactor);
+			
+			this.framebuffer = new Framebuffer("3D Render", displayFBWidth , displayFBHeight, true, false);
+			print(this.framebuffer.toString());
+			this.checkGLError("3D framebuffer setup");
+			
+			mirrorFBWidth = this.displayWidth;
+			mirrorFBHeight = this.displayHeight;
+			if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY) {
+				mirrorFBWidth = this.displayWidth / 2;
+				if(this.vrSettings.mixedRealityUnityLike)
+					mirrorFBHeight = this.displayHeight / 2;
+			}
+
+			if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY || this.vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON) {
+				this.framebufferMR = new Framebuffer("Mixed Reality Render", mirrorFBWidth, mirrorFBHeight, true, false);
+				print(this.framebufferMR.toString());
+				this.checkGLError("Mixed reality framebuffer setup");
+			}
+			
+			if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_FIRST_PERSON || (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY && this.vrSettings.mixedRealityUnityLike && vrSettings.mixedRealityMRPlusUndistorted)) {
+				this.framebufferUndistorted = new Framebuffer("Undistorted View Render", mirrorFBWidth, mirrorFBHeight, true, false);
+				print(this.framebufferUndistorted.toString());
+				this.checkGLError("Undistorted view framebuffer setup");
+			}
+			
+			GuiHandler.guiFramebuffer  = new Framebuffer("GUI", this.displayWidth, this.displayHeight, true, true);
+			print(GuiHandler.guiFramebuffer.toString());
+			this.checkGLError("GUI framebuffer setup");
+
+			KeyboardHandler.Framebuffer  = new Framebuffer("Keyboard",  this.displayWidth, this.displayHeight, true, true);
+			print(KeyboardHandler.Framebuffer.toString());
+			this.checkGLError("Keyboard framebuffer setup");
+
+			RadialHandler.Framebuffer  = new Framebuffer("Radial Menu",  this.displayWidth, this.displayHeight, true, true);
+			print(RadialHandler.Framebuffer.toString());
+			this.checkGLError("Radial framebuffer setup");
+
+			checkGLError("post color");
+
+			entityRenderer.setupClipPlanes();
+
+			this.eyeproj[0] = this.stereoProvider.getProjectionMatrix(null, 0, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance).transposed().toFloatBuffer();
+			this.eyeproj[1] = this.stereoProvider.getProjectionMatrix(null, 1, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance).transposed().toFloatBuffer();
+			this.cloudeyeproj[0] = this.stereoProvider.getProjectionMatrix(null, 0, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance * 4).transposed().toFloatBuffer();
+			this.cloudeyeproj[1] = this.stereoProvider.getProjectionMatrix(null, 1, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance * 4).transposed().toFloatBuffer();
+
+			if (this.vrSettings.useFsaa)
+			{
+				try //setup fsaa
+				{
+
+					// GL21.GL_SRGB8_ALPHA8
+					// GL11.GL_RGBA8
+					checkGLError("pre FSAA FBO creation");
+					// Lanczos downsample FBOs
+					fsaaFirstPassResultFBO = new Framebuffer("FSAA Pass1 FBO",EyeTextureSize.w, displayFBHeight,false, false,false, 0, -1);
+					//TODO: ugh, support multiple color attachments in Framebuffer....
+					fsaaLastPassResultFBO = new Framebuffer("FSAA Pass2 FBO",EyeTextureSize.w, EyeTextureSize.h,false, false,false, 0, -1);
+			
+					print(this.fsaaFirstPassResultFBO.toString());
+
+					checkGLError("FSAA FBO creation");
+
+					VRShaders.setupFSAA();
+
+					ShaderHelper.checkGLError("FBO init fsaa shader");
+				}
+
+				catch (Exception ex)
+				{
+					// We had an issue. Set the usual suspects to defaults...
+					this.vrSettings.useFsaa = false;
+					this.vrSettings.saveOptions();
+					System.out.println(ex.getMessage());
+					reinitFramebuffers = true;
+					return;
+				}
+			}
+			
+			try { //setup other shaders
+				VRShaders.setupDepthMask();
+				ShaderHelper.checkGLError("init depth shader");
+				VRShaders.setupFOVReduction();
+				ShaderHelper.checkGLError("init FOV shader");			
+		        this.renderGlobal.makeEntityOutlineShader();
+			} catch (Exception e) {
+				System.out.println(e.getMessage());
+				System.exit(-1);
+			}
+			
+			// Init screen size
+			if (this.currentScreen != null)
+			{
+				ScaledResolution scaledresolution = new ScaledResolution(this);
+				int k = scaledresolution.getScaledWidth();
+				int l = scaledresolution.getScaledHeight();
+				this.currentScreen.setWorldAndResolution(this, k, l);
+			}
+
+
+			System.out.println("[Minecrift] New render config:" +
+					"\nRender target width:  " + (true ? EyeTextureSize.w + EyeTextureSize.w: this.displayWidth) +
+					", height: " + (true ? Math.max(EyeTextureSize.h, EyeTextureSize.h) : this.displayHeight) +
+					(true ? " [Render scale: " + this.vrSettings.renderScaleFactor + "]" : "") +
+					(this.vrSettings.useFsaa ? " [FSAA Scale: " + this.vrSettings.renderScaleFactor + "]" : "") +
+					"\nDisplay target width: " + this.displayFBWidth + ", height: " + displayFBHeight);
+
+			// Init shaders
+			if (this.entityRenderer != null) {
+				if (shaderGroup != null)
+					shaderGroup.deleteShaderGroup();
+
+				lastShaderIndex = this.vrSettings.shaderIndex;
+				//shaderGroup = this.entityRenderer.initShaderGroup(framebuffer);
+			}
+
+			this.loadingScreen = new LoadingScreenRenderer(this);
+			
+			this.lastDisplayFBWidth = this.displayFBWidth;
+			this.lastDisplayFBHeight = this.displayFBHeight;
+			this.lastEnableVsync = this.gameSettings.enableVsync;
+			this.reinitFramebuffers = false;
+
+		}
+
+		if (changeNonDestructiveRenderConfig || this.reinitFramebuffers)
+		{
+			this.stereoProvider.configureRenderer(glConfig); //does nothing for Vive
+		}
+		
+	}
+
+	public void doStencilForEye(int i) {	
+		float[] verts = stereoProvider.getStencilMask(this.currentPass);
+		if (verts == null) return;
+			//START STENCIL TESTING - Yes I know there's about 15 better ways to do this.
+				GL11.glEnable(GL11.GL_STENCIL_TEST);
+				GlStateManager.disableAlpha();
+				GlStateManager.disableDepth();
+		        GlStateManager.disableTexture2D();
+				GlStateManager.disableCull();
+				
+				GL11.glStencilOp(GL11.GL_KEEP, GL11.GL_KEEP, GL11.GL_REPLACE);
+				GL11.glStencilMask(0xFF); // Write to stencil buffer
+				GlStateManager.clear(GL11.GL_STENCIL_BUFFER_BIT); // Clear stencil buffer (0 by default)
+				GL11.glStencilFunc(GL11.GL_ALWAYS, 0xFF, 0xFF); // Set any stencil to 1
+				GlStateManager.color(0, 0, 0);
+				GlStateManager.depthMask(false); // Don't write to depth buffer
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+				GlStateManager.pushMatrix();
+				GL11.glLoadIdentity();
+				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+				GlStateManager.pushMatrix();
+				GlStateManager.loadIdentity();
+				GlStateManager.ortho(0.0D, displayFBWidth,displayFBHeight, 0.0D, -10, 20.0D);
+				GlStateManager.viewport(0, 0, displayFBWidth, displayFBHeight);
+				//this viewport might be wrong for some shaders.
+				GL11.glBegin(GL11.GL_TRIANGLES);
+
+				for (int ix = 0;ix< verts.length;ix+=2) {
+					GL11.glVertex2f(verts[ix] * this.vrSettings.renderScaleFactor, verts[ix+1] * this.vrSettings.renderScaleFactor);
+				}
+				GL11.glEnd();	
+
+				GL11.glStencilFunc(GL11.GL_NOTEQUAL, 0xFF, 1);
+				GL11.glStencilOp(GL11.GL_KEEP, GL11.GL_KEEP, GL11.GL_KEEP);
+				GlStateManager.depthMask(true); // Do write to depth buffer
+				GL11.glStencilMask(0x0); // Dont Write to stencil buffer
+				
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+				GlStateManager.popMatrix();
+				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+				GlStateManager.popMatrix();
+				
+				GlStateManager.enableDepth();
+				GlStateManager.enableAlpha();
+				GlStateManager.enableTexture2D();
+				GlStateManager.enableCull();
+		
+				/// END STENCIL TESTING
+	}
+
+	public boolean clipPlanesChanged()
+	{
+		boolean changed = false;
+
+		if (this.world != null && this.world.provider != null)
+		{
+			if (this.world.provider.getDimensionType() != this.lastDimensionId)
+			{
+				changed = true;
+			}
+		}
+
+		if( this.gameSettings.renderDistanceChunks != this.lastRenderDistanceChunks ||
+				Config.isFogFancy() != this.lastFogFancy                                ||
+				Config.isFogFast() != this.lastFogFast)
+		{
+			changed = true;
+		}
+
+		
+		lastRenderDistanceChunks = this.gameSettings.renderDistanceChunks;
+		lastFogFancy = Config.isFogFancy();
+		lastFogFast = Config.isFogFast();
+		if (this.world != null && this.world.provider != null)
+			lastDimensionId = this.world.provider.getDimensionType();
+
+		return changed;
+	}
+
+	public GLConfig getLWJGLConfig(GLConfig glConfig)
+	{
+		// TODO: For LWJGL 3.0, this function may well be screwed...
+
+		// We need to retrieve certain pointers / handles from LWJGL
+		// for the Oculus SDK. However, these are not exposed by
+		// LWJGL, so use reflection to get hold of the data we need.
+
+		try
+		{
+			switch(LWJGLUtil.getPlatform())
+			{
+			case LWJGLUtil.PLATFORM_WINDOWS:
+			{
+				// Get HWND pointer...
+				if (fieldHwnd == null)
+				{
+					fieldHwnd = displayImpl.getClass().getDeclaredField("hwnd");
+					fieldHwnd.setAccessible(true);
+				}
+				glConfig.Window = (Long) fieldHwnd.get(displayImpl);
+				//System.out.println(String.format("[Minecrift] HWND: 0x%X", new Object[] {glConfig.Window}));
+				break;
+			}
+			case LWJGLUtil.PLATFORM_LINUX:
+			{
+				// Get Display and Window pointers...
+				if (fieldDisplay == null)
+				{
+					fieldDisplay = displayImpl.getClass().getDeclaredField("display");
+					fieldDisplay.setAccessible(true);
+				}
+				if (fieldWindow == null)
+				{
+					fieldWindow = displayImpl.getClass().getDeclaredField("current_window");
+					fieldWindow.setAccessible(true);
+				}
+				glConfig.Display = (Long) fieldDisplay.get(null);
+				glConfig.Window = (Long) fieldWindow.get(null);
+				//System.out.println(String.format("[Minecrift] Display: 0x%X", new Object[] {glConfig.Display}));
+				//System.out.println(String.format("[Minecrift] Window: 0x%X", new Object[] {glConfig.Window}));
+				break;
+			}
+			case LWJGLUtil.PLATFORM_MACOSX:
+			{
+				// Do nowt...
+				break;
+			}
+			default:
+				throw new Exception ("Current platform not supported!");
+			}
+		}
+		catch (Exception ex)
+		{
+			ex.printStackTrace();
+			glConfig = null;
+		}
+
+		return glConfig;
+	}
+	private int dispLastWidth, dispLastHeight;
+	public boolean wasDisplayResized()
+	{
+		int h = Display.getHeight();
+		int w = Display.getWidth();
+		
+		boolean was = dispLastHeight != h || dispLastWidth != w;
+		dispLastHeight = h;
+		dispLastWidth = w;
+		return was;
+	}
+
+	public void initMinecrift() throws Exception
+	{
+		this.lastGuiScale = this.gameSettings.guiScale;
+
+		// Get underlying LWJGL Display implementation
+		if (displayImpl == null)
+		{
+			try {
+				Method displayMethod = Display.class.getDeclaredMethod("getImplementation");
+				displayMethod.setAccessible(true);
+				displayImpl = displayMethod.invoke(null, (java.lang.Object[])null); // VIVE fix warning
+				System.out.println(String.format("[Minecrift] LWJGL Display implementation class: %s", new Object[]{displayImpl.getClass().toString()}));
+			}
+			catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+
+		try {
+			//Class.forName("com.mtbs3d.minecrift.provider.MCHydra").newInstance();//creates and registers MCHydra if it can be (if the libraries are found)
+			//hydraLibsAvailable = true;
+		} catch (NoClassDefFoundError e1) {
+			System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+		} catch( Exception e1) {
+			System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+		}
+
+		new MCOpenVR();
+		MCOpenVR.init();
+		this.stereoProvider = new OpenVRStereoRenderer();
+		this.vrPlayer = new OpenVRPlayer();
+		this.vrSettings.vrAllowCrawling = false;
+		//hmdInfo = PluginManager.configureHMD("oculus");
+
+		//register Trackers
+		vrPlayer.registerTracker(backpackTracker);
+		vrPlayer.registerTracker(bowTracker);
+		vrPlayer.registerTracker(climbTracker);
+		vrPlayer.registerTracker(autoFood);
+		vrPlayer.registerTracker(jumpTracker);
+		vrPlayer.registerTracker(rowTracker);
+		vrPlayer.registerTracker(runTracker);
+		vrPlayer.registerTracker(sneakTracker);
+		vrPlayer.registerTracker(swimTracker);
+		vrPlayer.registerTracker(swingTracker);
+		vrPlayer.registerTracker(teleportTracker);
+		vrPlayer.registerTracker(horseTracker);
+
+
+		//TODO: init new steroerenderer
+
+		nativeMouseCursor = Mouse.getNativeCursor();
+		try {
+			invisibleMouseCursor = new Cursor(1, 1, 0, 0, 1, BufferUtils.createIntBuffer(1), null);
+		} catch (LWJGLException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public void showNativeMouseCursor(boolean show)
+	{
+		if (show == lastShowMouseNative)
+			return;
+
+		lastShowMouseNative = show;
+
+		try
+		{
+			if (show)
+			{
+				Mouse.setNativeCursor(nativeMouseCursor);
+			}
+			else
+			{
+				Mouse.setNativeCursor(invisibleMouseCursor);
+			}
+		}
+		catch (LWJGLException e)
+		{
+			e.printStackTrace();
+		}
+	}
+
+	public double getCurrentTimeSecs()
+	{
+		return this.stereoProvider.getCurrentTimeSecs();
+	}
+
+boolean w;
+
+
+	private void doFSAA() {
+		if (this.fsaaFirstPassResultFBO == null){
+			this.reinitFramebuffers = true;
+			return;
+		} else {
+
+			GlStateManager.disableAlpha();
+			GlStateManager.disableBlend();
+			
+			// Setup ortho projection
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPushMatrix();
+				GL11.glLoadIdentity();
+				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+				GL11.glPushMatrix();
+					GL11.glLoadIdentity();
+
+					GL11.glTranslatef(0.0f, 0.0f, -.7f);
+					// Pass 1 - horizontal
+					// Now switch to 1st pass FSAA result target framebuffer
+					this.fsaaFirstPassResultFBO.bindFramebuffer(true);
+
+					// Bind the FBO Texture
+					this.framebuffer.bindFramebufferTexture();
+
+					GlStateManager.clearColor(1, 1, 1, 1.0f);
+					GlStateManager.clearDepth(1.0D);
+					GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);            // Clear Screen And Depth Buffer on the framebuffer
+
+					// Render onto the entire screen framebuffer
+					GlStateManager.viewport(0, 0, fsaaFirstPassResultFBO.framebufferWidth, fsaaFirstPassResultFBO.framebufferHeight);
+
+					// Set the downsampling shader as in use
+					ARBShaderObjects.glUseProgramObjectARB(VRShaders._Lanczos_shaderProgramId);
+
+					// Set up the fragment shader uniforms
+					ARBShaderObjects.glUniform1fARB(VRShaders._Lanczos_texelWidthOffsetUniform, 1.0f / (3.0f * (float) fsaaFirstPassResultFBO.framebufferWidth));
+					ARBShaderObjects.glUniform1fARB(VRShaders._Lanczos_texelHeightOffsetUniform, 0.0f);
+					ARBShaderObjects.glUniform1iARB(VRShaders._Lanczos_inputImageTextureUniform, 0);
+
+					GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);
+
+					drawQuad();
+
+					// checkGLError("After Lanczos Pass1");
+
+					// Pass 2 - Vertial
+					// Now switch to 2nd pass screen framebuffer
+					
+					fsaaLastPassResultFBO.bindFramebuffer(true);
+					//curr.selectTexture(0); //this is our Eye tex!
+					
+					checkGLError("postselect");
+					fsaaFirstPassResultFBO.bindFramebufferTexture();
+					
+					checkGLError("posttex");
+					
+					GlStateManager.viewport(0, 0, fsaaLastPassResultFBO.framebufferWidth, fsaaLastPassResultFBO.framebufferHeight);
+					
+					GlStateManager.clearColor(1, 1, 1, 1.0f);
+					GlStateManager.clearDepth(1.0D);
+					GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+					checkGLError("postclear");
+					// Bind the texture
+					GL13.glActiveTexture(GL13.GL_TEXTURE0);
+					checkGLError("postact");
+					// Set up the fragment shader uniforms for pass 2
+					ARBShaderObjects.glUniform1fARB(VRShaders._Lanczos_texelWidthOffsetUniform, 0.0f);
+					ARBShaderObjects.glUniform1fARB(VRShaders._Lanczos_texelHeightOffsetUniform, 1.0f / (3.0f * (float) framebufferEye0.framebufferHeight));
+					ARBShaderObjects.glUniform1iARB(VRShaders._Lanczos_inputImageTextureUniform, 0);
+					
+					drawQuad();
+
+					checkGLError("postdraw");
+					
+					// Stop shader use
+					ARBShaderObjects.glUseProgramObjectARB(0);
+					// checkGLError("After Lanczos Pass2");
+						
+					GlStateManager.enableAlpha();
+					GlStateManager.enableBlend();
+
+					GL11.glMatrixMode(GL11.GL_PROJECTION);
+					GL11.glPopMatrix();		
+				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+				GL11.glPopMatrix();
+		}
+	}
+
+
+	public void drawQuad()
+	{
+		// this func just draws a perfectly normal box with some texture coordinates
+		GL11.glBegin(GL11.GL_QUADS);
+
+		// Front Face
+		GL11.glTexCoord2f(0.0f, 0.0f); GL11.glVertex3f(-1.0f, -1.0f,  0.0f);  // Bottom Left Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 0.0f); GL11.glVertex3f( 1.0f, -1.0f,  0.0f);  // Bottom Right Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 1.0f); GL11.glVertex3f( 1.0f,  1.0f,  0.0f);  // Top Right Of The Texture and Quad
+		GL11.glTexCoord2f(0.0f, 1.0f); GL11.glVertex3f(-1.0f,  1.0f,  0.0f);  // Top Left Of The Texture and Quad
+
+		GL11.glEnd();
+	}
+
+	/**
+	 * Sets the listener of sounds
+	 */
+	public void updateSoundListener() {
+		boolean loaded  = (boolean) MCReflection.SoundManager_loaded.get(this.mcSoundHandler.sndManager);
+		if(loaded){
+			SoundSystem sndSystem = (SoundSystem) MCReflection.SoundManager_sndSystem.get(this.mcSoundHandler.sndManager);
+			Vec3d up = vrPlayer.vrdata_world_render.hmd.getCustomVector(new Vec3d(0, 1, 0));
+			Vec3d hmdPos = vrPlayer.vrdata_world_render.hmd.getPosition();
+			Vec3d hmdDir = vrPlayer.vrdata_world_render.hmd.getDirection();
+
+			if (sndSystem != null)
+			{
+				sndSystem.setListenerPosition((float)hmdPos.x, (float)hmdPos.y, (float)hmdPos.z);
+				sndSystem.setListenerOrientation((float)hmdDir.x, (float)hmdDir.y, (float)hmdDir.z, (float)up.x, (float)up.y, (float)up.z);
+			}
+		}
+	}
+
+	private static void sleepNanos (long nanoDelay)
+	{
+		final long end = System.nanoTime() + nanoDelay;
+		do
+		{
+			Thread.yield();  // This is a busy wait sadly...
+		}
+		while (System.nanoTime() < end);
+	}
+
+	private void addRunTickTimeNanos(long runTickTime)
+	{
+		int i = 0;
+		medianRunTickTimeNanos = runTickTime;
+
+		if (this.vrSettings.smoothRunTickCount < 1)
+			this.vrSettings.smoothRunTickCount = 1;
+
+		if (this.vrSettings.smoothRunTickCount % 2 == 0)
+		{
+			// Need an odd number for this
+			this.vrSettings.smoothRunTickCount++;
+		}
+
+		runTickTimeNanos.addFirst(runTickTime);
+		while (runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+			runTickTimeNanos.removeLast();
+
+		if (runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount)
+		{
+			Long[] array = new Long[runTickTimeNanos.size()];
+			for (Iterator itr = runTickTimeNanos.iterator(); itr.hasNext(); i++)
+			{
+				array[i] = (Long)itr.next();
+			}
+			Arrays.sort(array);
+			medianRunTickTimeNanos = array[array.length / 2];
+		}
+	}
+
+	private long getMedianRunTickTimeNanos()
+	{
+		return medianRunTickTimeNanos;
+	}
+
+	public void triggerYawTransition(boolean isPositive) {
+	//	this.lookaimController.triggerYawTransition(isPositive);
+	}
+
+	public void print(String s)
+	{
+		s = s.replace("\n", "\n[Minecrift] ");
+		System.out.println("[Minecrift] " + s);
+	}
+	
+	public float watereffect, portaleffect, pumpkineffect;
+	private boolean renderSingleView(int eye, float nano) {
+		boolean shouldupdate = false;
+	
+				GlStateManager.clearColor(0f, 0, 0, 1f);	
+				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+				GlStateManager.enableTexture2D();	
+				GlStateManager.enableDepth();
+				
+						
+			this.mcProfiler.startSection("updateCameraAndRender");
+				if (!this.skipRenderWorld)
+				{
+					//Forge calls onRenderTickStart > move to ER.drawFrameBuffer
+	
+					///THIS IS WHERE EVERYTHING IS RENDERED
+						this.entityRenderer.updateCameraAndRender( nano, System.nanoTime());
+						
+					//Forge calls onRenderTickEnd > move to ER.drawFrameBuffer						
+				}
+			this.mcProfiler.endSection();
+			checkGLError("postucr " + eye);
+
+			if(currentPass == renderPass.Left || currentPass == renderPass.Right) {	
+				//copies the rendered scene to eye tex with fsaa and other postprocessing effects.
+				this.mcProfiler.startSection("postprocesseye");
+
+				Framebuffer source = this.framebuffer;
+
+				if (this.vrSettings.useFsaa)
+				{
+					this.mcProfiler.startSection("fsaa");
+					doFSAA();
+					source = fsaaLastPassResultFBO;
+					checkGLError("fsaa " + eye);
+					this.mcProfiler.endSection();
+				}
+
+				if(currentPass == renderPass.Left)	
+					framebufferEye0.bindFramebuffer(true); //draw to L eye tex
+				else
+					framebufferEye1.bindFramebuffer(true); //draw to R eye tex
+
+				if(vrSettings.useFOVReduction && vrPlayer.getFreeMove()){
+					if( player !=null && (Math.abs(player.moveForward) > 0 || Math.abs(player.moveStrafing) > 0)) {	
+						fov -=0.05;
+						if(fov < 0.22) fov = 0.22f;
+					} else {
+						fov +=0.01;
+						if(fov > 0.8) fov = 0.8f;				
+					}
+				} else {
+					fov = 1f;
+				}
+				
+				ARBShaderObjects.glUseProgramObjectARB(VRShaders._FOVReduction_shaderProgramId);
+				ARBShaderObjects.glUniform1iARB(VRShaders._FOVReduction_TextureUniform, 0);
+		
+				if(pumpkineffect > 0){
+					ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, 0.25f);
+					ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.0f);
+				} else{
+					ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, fov);
+					ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.06f);
+				}
+				
+				// VIVE start - screen flash when hurt instead of view tilt
+				float r = 0, k = 0;
+				// VIVE start - screen flash when hurt instead of view tilt
+				float time =  (float) (System.currentTimeMillis() - usageSnooper.getMinecraftStartTimeMillis()) / 1000;
+				if (player!=null && world !=null) {
+					
+					if(entityRenderer.inwater){
+						watereffect = 1.3f;
+					} else {
+						if(watereffect == 1.3f) watereffect = 2.3f;
+						watereffect -= (1f/60f);
+						if(watereffect < 0) watereffect = 0;
+					}
+					
+					if(Config.isShaders()) watereffect = 0; //dont stack.
+					
+					if(entityRenderer.inportal){
+						portaleffect = 1f;
+					} else {
+						portaleffect -= (1f/60f);
+						if(portaleffect < 0) portaleffect = 0;
+					}
+					
+					float var3 = (float)player.hurtTime - nano;
+
+					float percent = 1 - player.getHealth() / player.getMaxHealth();
+					percent = (percent-0.5f) * 0.75f;
+
+					if (var3>0.0f)
+					{
+						var3 /= (float) player.maxHurtTime;
+						var3 = percent + MathHelper.sin(var3 * var3 * var3 * var3 * (float) Math.PI) * 0.5f;
+						r = var3;
+					} else {
+						r =  (float) (percent * Math.abs(Math.sin(2.5f*time/(1-percent+.1) )));
+						if (player.isCreative()) r = 0;
+					}
+					
+					if(entityRenderer.inblock && player.isDead == false){
+						//k = (float) entityRenderer.itemRenderer.inBlock;
+						
+					}
+				
+					if (player.isPlayerSleeping()){
+						if(k<0.8)k=.8f;
+					}
+					
+					if (MCOpenVR.isWalkingAbout){
+						if(k<0.8)k=.5f;
+					}
+						
+				} else {
+					watereffect = 0;
+					portaleffect = 0;
+				}
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_HealthAlpha, r);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_BlackAlpha, k);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_time,time);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_waterAmplitude, watereffect);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_portalAmplitutde, portaleffect);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_pumpkinAmplitutde, pumpkineffect);		
+				ARBShaderObjects.glUniform1iARB(VRShaders._Overlay_eye, currentPass == currentPass.Left ? 1 : -1);		
+				
+				source.framebufferRender(framebufferEye0.framebufferWidth, framebufferEye0.framebufferHeight);
+
+				ARBShaderObjects.glUseProgramObjectARB(0);
+
+				checkGLError("post-draw " + eye);
+
+				this.mcProfiler.endSection();
+
+				//this.mcProfiler.startSection("OpenGL Finish");
+				//	GL11.glFinish();//DO NOT LEAVE THIS UNCOMMENTED
+				//this.mcProfiler.endSection();
+
+			}
+
+
+		this.mcProfiler.startSection("mirror");
+			shouldupdate = copyToMirror(this.currentPass);
+			checkGLError("post-mirror " + eye);
+		this.mcProfiler.endSection();
+
+		return shouldupdate;
+	}
+
+	public float getFrameDelta() {
+		return frameDelta;
+	}
+	
+	private float angleNormalize(float angle) {
+		angle %= 360;
+		if (angle < 0) angle += 360;
+		return angle;
+	}
+	
+	
+	private float angleDiff(float a, float b) {
+		float d = Math.abs(a - b) % 360;
+		float r = d > 180 ? 360 - d : d;
+		
+		int sign = (a - b >= 0 && a - b <= 180) || (a - b <=-180 && a- b>= -360) ? 1 : -1;
+		return r * sign;
+	
+	}
+	
+	// FORGE
+	public ItemColors getItemColors()
+	{
+		return this.itemColors;
+	}
+	
+    public SearchTreeManager getSearchTreeManager()
+    {
+    	return this.searchTreeManager;
+    }
+    //
 }
