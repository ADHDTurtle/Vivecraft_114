--- a/net/minecraft/client/gui/IngameGui.java
+++ b/net/minecraft/client/gui/IngameGui.java
@@ -6,12 +6,18 @@
 import com.google.common.collect.Ordering;
 import com.mojang.blaze3d.platform.GLX;
 import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.GlStateManager.DestFactor;
+import com.mojang.blaze3d.platform.GlStateManager.SourceFactor;
+
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.stream.Collectors;
+
+import org.lwjgl.opengl.GL11;
+
 import net.minecraft.block.Blocks;
 import net.minecraft.client.GameSettings;
 import net.minecraft.client.Minecraft;
@@ -23,6 +29,7 @@
 import net.minecraft.client.gui.overlay.DebugOverlayGui;
 import net.minecraft.client.gui.overlay.PlayerTabOverlayGui;
 import net.minecraft.client.gui.overlay.SubtitleOverlayGui;
+import net.minecraft.client.gui.screen.Screen;
 import net.minecraft.client.gui.screen.inventory.ContainerScreen;
 import net.minecraft.client.renderer.ActiveRenderInfo;
 import net.minecraft.client.renderer.BufferBuilder;
@@ -1552,4 +1559,54 @@
     {
         this.overlayDebug.func_212921_a();
     }
+    
+	//VIVECRAFT ADDITIONS ***********************************
+
+	public void drawMouseMenuQuad(int mouseX, int mouseY)
+	{	
+		GlStateManager.enableBlend();
+		GlStateManager.enableAlphaTest();
+		GlStateManager.disableDepthTest();
+		GlStateManager.disableLighting();
+		GlStateManager.color4f(1, 1, 1, 1);
+
+		this.mc.getTextureManager().bindTexture(GUI_ICONS_LOCATION);
+		float menuMousePointerSize = 16f * this.mc.vrSettings.menuCrosshairScale;
+		
+		//Why didnt we think of this sooner?
+		/*GlStateManager.colorMask(false, false, false, true);
+		GlStateManager.blendFunc(SourceFactor.CONSTANT_ALPHA, DestFactor.ZERO);
+		drawCentredTexturedModalRect(mouseX, mouseY, menuMousePointerSize, menuMousePointerSize, 0, 0, 15, 15);
+		
+		GlStateManager.blendFunc(SourceFactor.ONE_MINUS_DST_COLOR, DestFactor.ONE_MINUS_SRC_COLOR);
+		GlStateManager.colorMask(true, true, true, false);
+		drawCentredTexturedModalRect(mouseX, mouseY, menuMousePointerSize, menuMousePointerSize, 0, 0, 15, 15);*/
+
+		// Turns out all we needed was some blendFuncSeparate magic :)
+		// Also color DestFactor of ZERO produces better results with non-white crosshairs
+		GlStateManager.blendFuncSeparate(SourceFactor.ONE_MINUS_DST_COLOR, DestFactor.ZERO, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+		drawCentredTexturedModalRect(mouseX, mouseY, menuMousePointerSize, menuMousePointerSize, 0, 0, 15, 15);
+
+		GlStateManager.disableBlend();
+		GlStateManager.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+		GlStateManager.enableDepthTest();
+		GlStateManager.enableLighting();
+		//GlStateManager.colorMask(true, true, true, false);
+	}
+	/**
+	 * Draws a centred textured rectangle at the stored z-value. Args: x, y, width, height, u, v, texwidth, texheight
+	 */
+	public void drawCentredTexturedModalRect(int centreX, int centreY, float width, float height, int u, int v, int texWidth, int texHeight)
+	{   	
+		float f = 0.00390625F;
+		float f1 = 0.00390625F;
+		Tessellator tessellator = Tessellator.getInstance();
+		tessellator.getBuffer().begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);
+		tessellator.getBuffer().pos(0, 0, 0).tex(u, v);
+		tessellator.getBuffer().pos((double)(centreX - (width / 2f)), (double)(centreY + (height / 2f)), (double)this.blitOffset).tex((double)((float)(u + 0) * f), (double)((float)(v + texHeight) * f1)).endVertex();
+		tessellator.getBuffer().pos((double)(centreX + (width / 2f)), (double)(centreY + (height / 2f)), (double)this.blitOffset).tex( (double)((float)(u + texWidth) * f), (double)((float)(v + texHeight) * f1)).endVertex();
+		tessellator.getBuffer().pos((double)(centreX + (width / 2f)), (double)(centreY - (height / 2f)), (double)this.blitOffset).tex( (double)((float)(u + texWidth) * f), (double)((float)(v + 0) * f1)).endVertex();
+		tessellator.getBuffer().pos((double)(centreX - (width / 2f)), (double)(centreY - (height / 2f)), (double)this.blitOffset).tex( (double)((float)(u + 0) * f), (double)((float)(v + 0) * f1)).endVertex();
+		tessellator.draw();
+	}
 }
